%\vspace*{3ex plus 0.6fil}
\begin{center}
\addcontentsline{toc}{chapter}{Abstract}

{\large\bf
   AN ABSTRACT\\[3ex]
   A PORT in Stormy SEAs: Using Past Problems to Prevent Future Failures\\[2ex]
   by\\[3ex]
   Preston K.\ Moore\\[3ex]
   %% Advisor name
   Advisor: Justin\ Cappos\\[2ex]
   %% Co-advisor, or comment out
   Co-Advisor: Phyllis Frankl
}\\[3ex]
Submitted in Partial Fulfillment of the Requirements\\[2ex]
for the Degree of Doctor of Philosophy (Computer Science)\\[3ex]
% The date appearing on the title page should be the month and year of
% the expected degree award (e.g., January 20XX or May/June 20XX)
% and not the completion date of the work.
May 2022
\end{center}

\vspace*{2.5ex}

%Paragraph 1
%%Software repositories, or servers that host and distribute
%%software updates, are becoming increasingly important in a wide variety of
%%settings,

In order to be able to scale with demand software must be deployed and executed on
many diverse platforms.
Unfortunately, if not handled appropriately, 
the differences between these platforms,
can cause even well-tested applications to fail upon deployment.
Anticipating and handling all the different combinations of
software and hardware that can affect an applicationâ€™s ability to operate
in a given deployment environment is almost impossible.
To make matters worse,
recovering from these post-deployment failures is expensive and
detrimental to user experience.
What is needed is a way to detect situations where an application may fail
\textit{before} it is deployed so that its deficiencies can be corrected without the negative consequences of a failure.

In searching for an answer to this problem one key observation became clear:
the causes of these environment-related failures
often can be seen in the
communications between an application and its environment. These communications can include the
system calls it makes or the messages it sends across a network.
By taking advantage of this property, we were able to design two systems that allow developers to catch environmental bugs
before an application is deployed. 
The first system, known as CrashSimulator,
uses a novel technique we have named Simulating Environmental Anomalies (SEA).
This technique allows developers to record features from one environment
after an application has failed and use them to identify if other
applications are likely to fail in a similar manner.
The second system,
known as PORT,
is a domain specific programming language that allows developers
to quickly write expressive programs that can analyze a stream of communications between an application and  its environment.
PORT programs can both detect opportunities to
simulate a failure-causing feature, known as an anomaly, \textit{and} modify the stream so that anomaly is present.

To realize the SEA technique we implemented a tool called CrashSimulator.
We were able to use it to find many high impact bugs in popular,
battle tested applications.
Based on the results of a user study we also found that,
while these developers could use the tool successfully,
capturing new anomalies was difficult.
As a result of this finding we created PORT
in order to ease the process of writing checkers and mutators.
To see how well PORT achieved its intended purpose it to recreate and
replace the checkers and mutators used in our original SEA work.
These new PORT programs were shorter, easier to read, and easier to
maintain than the lengthy and complex Python scripts they replaced.
We also took advantage of PORT's extensibility by expanding SEA to USB
traffic.
We were also able to write programs that could identify patterns in and
modify streams of USB traffic.
Using this capability we were able to write programs that could
detect BADUSB style attacks in recorded streams and modify innocent streams
so that they contained simulated attacks.
The former could be used alongside a USB capture program to detect attacks
on real systems while the latter could be used to test existing defenses.

%Paragraph 4
Our hope is that these tools and techniques will see wide
adoption and use in improving application reliability and security. We envision this could occur in two different ways. The first would be wide-spread adoption of these
tools in continuous
integration and deployment pipelines. This could enable current and future
applications to be tested against an ever-increasing repository of
environmental bugs.
The second would be the development of a user community in which developers can exchange PORT programs and their experiences to increase knowledge about what situations have caused failures.  Collectively, 
this could enable the introduction of new applications without the catastrophic consequences of a deployment failure. 

\vspace*{3ex plus 1fil}
