%\vspace*{3ex plus 0.6fil}
\begin{center}
\addcontentsline{toc}{chapter}{Abstract}

{\large\bf
   AN ABSTRACT\\[3ex]
   A PORT in Stormy SEAs: Using Past Problems to Prevent Future Failures\\[2ex]
   by\\[3ex]
   Preston K.\ Moore\\[3ex]
   %% Advisor name
   Advisor: Justin\ Cappos\\[2ex]
   %% Co-advisor, or comment out
   Co-Advisor: Phyllis Frankl
}\\[3ex]
Submitted in Partial Fulfillment of the Requirements\\[2ex]
for the Degree of Doctor of Philosophy (Computer Science)\\[3ex]
% The date appearing on the title page should be the month and year of
% the expected degree award (e.g., January 20XX or May/June 20XX)
% and not the completion date of the work.
May 2022
\end{center}

\vspace*{2.5ex}

%Paragraph 1
%%Software repositories, or servers that host and distribute
%%software updates, are becoming increasingly important in a wide variety of
%%settings,

In order to be able to scale with demand software must be deployed and executed on
many diverse platforms.
Unfortunately, if not handled appropriately, 
the differences between these platforms,
can cause even well-tested applications to fail upon deployment.
Anticipating and handling all the different combinations of
software and hardware that can affect an application’s ability to operate
in a given deployment environment is almost impossible.
To make matters worse,
recovering from these post-deployment failures is expensive and
detrimental to user experience.
What is needed is a way to detect situations where an application may fail
\textit{before} it is deployed so that its deficiencies can be corrected without the negative consequences of a failure.

In searching for an answer to this problem one key observation became clear:
the causes of these environment-related failures,
referred to as anomalies,
often can be seen in the
communications between an application and its environment, such as the
system calls it makes or the messages it sends across a network.
By taking advantage of this property, we were able to design two systems that allow developers to catch environmental bugs
before an application is deployed. 
The first,
which we refer to as the SEA technique,
allows developers to record features from an environment
that has caused one application to fail and use them to identify which other
applications are likely to fail in a similar manner when deployed to that same environment.
The second,
known as PORT,
is a domain specific language that allows developers
to quickly write expressive programs that can analyze a stream made up of
an application’s communications with its environment.
PORT programs can both detect opportunities to
simulate a failure-causing feature \textit{and} modify the stream so that
the feature is present.

To realize the SEA technique we implemented a tool called CrashSimulator.
It allows developers to capture environmental anomalies visible in the
system calls an application makes and use them to test applications to see
if they would fail were they to experience them in reality.
We were able to use CrashSimulator to find many high impact bugs in
popular,
battle tested applications.

Next, we conducted a user study with CrashSimulator in order to determine
how well developers with varying skill levels could use it.
This study found that,
while these developers could use the tool successfully,
capturing new anomalies was difficult.
As a result of this finding we create PORT,
a domain specific language
specifically tailored toward recognizing patterns and making modifications
to streams of application activity.
Our goal was to ease the process of
writing checkers and mutators so that SEA could easily and widely used.

To see how well PORT achieved its intended purpose it to recreate and
replace the checkers and mutators used in our original SEA work.
These new PORT programs were shorter, easier to read, and easier to
maintain than the lengthy and complex Python scripts they replaced.
We also took advantage of PORT's extensibility by expanding SEA to USB
traffic.
This allowed us to write programs that could identify patterns in and
modify streams of USB traffic.
Using this capability we were able to write programs that could
detect BADUSB style attacks in recorded streams and modify innocent streams
so that they containd simulated attacks.
The former could be used alongside a USB capture program to detect attacks
on real systems while the latter could be used to test existing defenses.

%Paragraph 4
Our hope is that these tools and techniques will see wide
adoption and use in improving application reliability and security.
We see production-ready versions of these tools being used in continuous
integration and deployment pipelines in order to allow current and future
applications to be tested against an ever-increasing repository of
environmental bugs.
We also see a world where developers can exchange PORT programs so as a
means of distributing knowledge about what situations have caused failures
so that applications that have never had to experience a situation can
be protected against them.

\vspace*{3ex plus 1fil}
