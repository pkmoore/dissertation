%\vspace*{3ex plus 0.6fil}
\begin{center}
\addcontentsline{toc}{chapter}{Abstract}

{\large\bf
   AN ABSTRACT\\[3ex]
   A PORT in Stormy SEAs: Leveraging Past Problems to Prevent Future Failures\\[2ex]
   by\\[3ex]
   Preston K.\ Moore\\[3ex]
   %% Advisor name
   Advisor: Justin\ Cappos\\[2ex]
   %% Co-advisor, or comment out
   Co-Advisor: Phyllis Frankl
}\\[3ex]
Submitted in Partial Fulfillment of the Requirements\\[2ex]
for the Degree of Doctor of Philosophy (Computer Science)\\[3ex]
% The date appearing on the title page should be the month and year of
% the expected degree award (e.g., January 20XX or May/June 20XX)
% and not the completion date of the work.
May 2022
\end{center}

\vspace*{2.5ex}

%Paragraph 1
%%Software repositories, or servers that host and distribute
%%software updates, are becoming increasingly important in a wide variety of
%%settings,

In order to meet the needs of an ever-growing user base,
software must be deployed and executed into an
increasing set of new and unusual environments.
Unfortunately, if not handled appropriately, any
variations between these platforms
could cause even well-tested applications to fail upon deployment.
Anticipating and being prepared to handle all the potential combinations of
software and hardware that can affect an applicationâ€™s ability to operate
in a given deployment environment is an almost impossible task.
To make matters worse,
recovering from these post-deployment failures is expensive,
harmful to user experience,
and damaging to developer reputations.
What is needed is a way to detect situations where an application may fail
\textit{before} it is deployed so that its deficiencies can be corrected without the negative consequences of a failure.
In searching for an answer to this problem one key observation became clear:
the causes of these environment-related failures
often can be seen in the
communications between an application and its environment. These communications can include the
system calls it makes or the messages it sends across a network.
By taking advantage of this concept,
we were able to develop two techniques that allow developers to catch environmental bugs
before an application is deployed. 
The first technique,
known as Simulating Environmental Anomalies (SEA),
allows developers to record features from one environment
after an application has failed and use them to identify if other
applications are likely to fail in a similar manner.
The second technique involved 
applying event processing strategies
to application recordings
using a new  domain specific programming language,
in order to allow developers to
to quickly write expressive programs that can analyze a stream of communications between an application and  its environment.

To realize the SEA technique we implemented a tool called CrashSimulator.
We were able to use it to find many high impact bugs in popular,
battle tested applications.
Based on the results of a user study we found that,
while developers could use the tool successfully,
capturing a problematic feature, known as an anomaly, was difficult.
As a direct result of this observation we knew that a domain specific language would be required to make SEA usable in practical applications.
 To this end, we created PORT
which uses the aforementioned event processing techniques
to ease the development of recording and simulating an anomaly.
PORT programs can both detect opportunities to
simulate an anomaly, \textit{and} modify the stream so that anomaly is present.

We tested how well PORT achieved its intended purpose by using it to recreate and
replace the anomalies used in our original SEA work.
These new PORT programs were shorter, easier to read, and easier to
maintain than the lengthy and complex Python scripts they replaced.
We also took advantage of PORT's extensibility by expanding SEA to USB
traffic.
We were also able to write programs that could identify patterns in and
modify recordings of USB communications.
Using this capability we were able to simulate
BADUSB style attacks in recorded streams by modifying innocent streams
so that they contained the harmful features of such an attack.
We were also able to simulate device identifier conflicts -- a situation that has
plagued operating system developers in the past.
We do so using a PORT program that modifies a recording so that these conflicts
are present in device registration frames.
In both cases, these recordings could be used
to test how a system might respond should they occur in the real world.

%Paragraph 4
Our hope is that these tools and techniques will see wide
adoption and use in improving application reliability and security. We envision this could occur in two different ways. The first would be wide-spread adoption of these
tools in continuous
integration and deployment pipelines. This could enable current and future
applications to be tested against an ever-increasing repository of
environmental bugs.
The second would be the development of a user community in which developers can exchange PORT programs and their experiences to increase knowledge about what situations have caused failures.  Collectively, 
this could enable the introduction of new applications without the catastrophic consequences of a deployment failure. 

\vspace*{3ex plus 1fil}
