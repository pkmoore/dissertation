\section{Conclusion}
\label{SEC:conclusion}

As we have discussed,
it is common for an application
to fail upon deployment because of unexpected interactions
with its environment.
Although finding and eliminating
faults in an application is a key concern for software developers, it is
impractical to test it in every environment it will face.
To address this problem, we developed \textit{Simulating Environmental
Anomalies} (SEA).
SEA is beneficial for developers because it allows
the effort spent debugging failures in a given environment
to be preserved and reused programmatically to test whether
future applications will also fail.
As this process is repeated,
a corpus of bug-causing aspects,
known as ``anomalies,''
along with mutators and checkers that characterize these anomalies,
can be accumulated. In doing so, developers have an ever-increasing capability
to test applications in situations
that proved problematic in the past.

We built a concrete implementation of SEA
called CrashSimulator that implements
the technique by simulating environmental
anomalies extracted from the system calls an application makes.
Operating on system calls gives the tool a ``universal'' way to
encode and inject anomalies. Consequently, a set of mutations can be
collected from existing applications for use in testing others.
Our evaluation of CrashSimulator
has shown that this technique is
effective at finding bugs in well tested software.
In total,
65 new bugs were identified in popular applications.
These bugs, if triggered in the wild,
could lead to effects ranging from simple program hangs
to security vulnerabilities and data loss.

Given that the technique has
proven effective, future work to expand its use is warranted. This work includes
developing a public repository of anomalies
that can be applied to new or existing applications.
We are also exploring
opportunities to further automate the discovery process
and improve the way anomalies are specified using a
domain specific language.
As this research evolves, we will focus on analyzing how an
application attempts
to recover from the anomalies.  This would allow
us to determine whether
an application is correctly recovering
from an error, or carrying out some incorrect response.
